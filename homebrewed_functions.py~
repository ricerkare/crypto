def xor(S, T): # assumes S, T are byte strings
    return "".join([chr(s ^ t) for s, t in zip(S, T)]).encode("utf-8", "replace")

def single_char_xors(msg):
    for i in range(256):
        yield [chr(i).encode("utf-8"), xor(msg, (chr(i)*len(msg)).encode("utf-8"))]

def repeating_xor(msg, key): # for byte strings msg and key
    return "".join([chr(msg[i] ^ key[i%len(key)]) for i in range(len(msg))]).encode("utf-8", "replace")

# Assumes there is at least one three-letter word in the string S. Doesn't look up contractions (yet).
def real_word_count(S): 
    count = 0
    for word in filter(lambda s: s.isalpha() and len(s) >= 3, S.split(' ')):
        if word.lower() in words:
            count += 1
    return count

def freq_score(S):
    return sum([char_freqs[ch.lower()] for ch in S if ch in char_freqs])

def break_single_char_xor(ciphertext, method = "dictionary", show_metric = False): 
    if method == "dictionary":
        Key = ''
        max_word_count = 0
        for x in single_char_xors(ciphertext):
            if real_word_count(x[1].decode()) > max_word_count:
                max_word_count = real_word_count(x[1])
                Key = x[0]
        if show_metric:
            return [Key, max_word_count]
        else:
            return Key
    elif method == "char_freqs":
        Key = ''
        max_freq = 0.0
        for x in single_char_xors(ciphertext):
            if float(freq_score(x[1].decode("utf-8", "replace"))) > max_freq:
                max_freq = freq_score(x[1])
                Key = x[0]
        if show_metric:
            return [Key, max_freq]
        else:
            return Key
